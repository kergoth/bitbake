- Reimplement the interactive mode as a proper ui
- Move the LAYERDIR expansion hack into DataSmart, as that's where code that
  depends upon its internals belongs
- Continue dropping fatal/SystemExit/sys.exit usage in favor of raising
  appropriate exceptions
- Continue pylint / pyflakes / pychecker / pep8 fixups
- Drop os.system usage in favor of direct subprocess usage or a subprocess
  wrapper
- Kill the execution of 'tee' for the task log file in build.py
- Variable reference tracking

  - Test moving the parsing out of the constructors and into factory functions
    instead, and move the object caching as decorators of those functions.
  - Start integrating visitor/transformer bits.

- Fix up the exception handling

  - Kill exec_task's catch of FuncFailed, instead catch it in the other
    callers of exec_task/exec_func
  - What exactly is the purpose of the "EventException"?  I can see using an
    exception like that, *perhaps*, to abstract away exceptions raised by
    event handlers, but it has no place in bb.build.exec_task

- Leverage the python logging module

  - Create a new logging Handler which instantiates MsgBase derived objects
    and passes them along, either via bb.event or directly over the
    appropriate queues to the other processes.
  - Alter the bb.msg functions to use the logging module.
  - Convert bb modules to stop using the bb.msg functions.
  - Switch the messaging wrappers in the bb package to use the logging module
    directly, as we'll be deprecating the bb.msg versions, but these should
    stay around for the metadata to use.
  - Deprecate the bb.msg functions.
  - Do we want to use the logging module in any of the UIs, for local
    messages, as well?  If we do, we don't want those to use our handler which
    sends the Msg events to the UI :)
    Looks like we may be able to use removeHandler.. will have to see how it
    interacts with parent/child loggers.

Long term, high impact:

  - Change override application to actually *move* it over -- so the original
    override specific version of the variable goes away, rather than sticking
    around as a duplicate.
  - Change the behavior when a variable is referenced and is unset.  Today, it
    evaluates to ${FOO} and then shell has a chance to expand it, but this is
    far from ideal.  We had considered evaluating it to the empty string, but
    that has other potential problems.  Frans Meulenbroeks has proposed just
    erroring when this occurs, as we can always define default values for the
    variables in bitbake.conf.  This seems reasonable.  My only concern with
    that is the case where you want to reference a shell variable with odd
    characters in it -- where you'd have to use ${} style shell variable
    expansion rather than normal $.  To handle that case, we'd really need a
    way to escape / disable bitbake variable expansion, \${} perhaps.

Uncertain:

  - Leverage the python 2.6 multiprocessing module

    - Worker processes for bb.cooker
    - Server / UI processes

  - Create a bitbake configuration class which is utilized by the library, not
    just bin/bitbake.  This class should be responsible for extracting
    configuration parameters from the metadata for bitbake internal use, as well
    as pulling specific items like BBDEBUG, and importing settings from an
    optparse options object.

  - Python version bits

    - Utilize the new string formatting where appropriate
    - Do we need to take into account the bytes literals changes?
    - Do we have any file-like objects that would benefit from using the "io"
      module?
    - Do we want to leverage the abstract base classes in collections?
    - Aside: Set methods now accept multiple iterables
